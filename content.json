[{"title":"node.js搭建一个项目","date":"2017-06-09T15:56:00.000Z","path":"2017/06/09/nodejs搭建搭建一个简单的服务器/","text":"node.js搭建一个项目记录一下使用node.js+express+jade启动一个简单项目的流程 创建一个新的项目文件夹 mkdir nodework 初始化一个项目 npm init 安装express npm install express --save 创建一个入口文件touch app.js 编写入口文件 12345678910111213141516171819202122232425262728293031323334var express = require('express');// 实例化app 也可以使用express.createServer()来实例化，但是已被弃用var app = express();// :name后面的？号表示name是一个可选的参数，即使不提供name，这个路由也会被加载// 这里是提供了三个路由// xpress 使用 path-to-regexp 来匹配路由路径app.get('/stooges/:name?', function(req,res,next) &#123; var name = req.params.name; switch (name ? name.toLowerCase() : '') &#123; case 'larry': case 'curly': case 'moe': res.send(name + ' is good'); break; default: next(); &#125;&#125;);// 当上一个方法不满足时，会被这个路由所处理app.get('/stooges/*?', function(req, res)&#123; res.send('no stooges listed');&#125;)// 默认的路由，程序的默认访问路径app.get('/?', function(req, res) &#123; res.send('hello word');&#125;);var port = 8080;app.listen(port);console.log('listening on the port ' + port); 安装模版jadenpm install jade --save 更新app.js文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var express = require('express');// 实例化app 也可以使用express.createServer()来实例化，但是已被弃用var app = express();// 引入jade模版引擎app.set('view engine', 'jade');app.set('view options', &#123;layout: true&#125;);// 所有的视图都存放在views的目录下面 相对于代码文件运行(__dirname)的下级目录app.set('views', __dirname + '/views');// :name后面的？号表示name是一个可选的参数，即使不提供name，这个路由也会被加载// 这里是提供了三个路由// xpress 使用 path-to-regexp 来匹配路由路径app.get('/stooges/:name?', function(req,res,next) &#123; var name = req.params.name; switch (name ? name.toLowerCase() : '') &#123; case 'larry': case 'curly': case 'moe': // res.send(name + ' is good'); res.render('stooges', &#123;stooge: name&#125;); break; default: next(); &#125;&#125;);// 当上一个方法不满足时，会被这个路由所处理app.get('/stooges/*?', function(req, res)&#123; // res.send('no stooges listed'); res.render('stooges', &#123;stooge: null&#125;)&#125;)// 默认的路由，程序的默认访问路径app.get('/?', function(req, res) &#123; // send 是直接输出到页面上面 render会查找参数里面同名的jade文件 // res.send('hello word'); res.render('index');&#125;);var port = 8080;app.listen(port);console.log('listening on the port ' + port);// index.jadeextends layoutblock content h1 hello world// layout.jadedoctype htmlhtml(lang='en') head title my web site block scripts block content// stooges.jadeextends layoutblock content if(stooge) p #&#123;stooge&#125; is my love else p no stooge listed 命令行启动项目 node app.js 访问页面查看效果 被第一个路由解析 被第二个路由解析 访问缺省路由","tags":[{"name":"node.js express","slug":"node-js-express","permalink":"http://blog.woodchan.com/tags/node-js-express/"}]},{"title":"markdown的语法","date":"2017-05-29T03:54:44.000Z","path":"2017/05/29/markdown的语法/","text":"段落引用标签 markdown支持html语法，所以有两种写法，html段落引用标签，前后会缩进，并且第一行会有&lt; p&gt;效果，但是可以添加自定义的css样式，使用markdown的语法写比较简洁： 效果：html标签可以实现居中的效果嵌套使用 markdown标签 markdown引用第二次 代码： 12345678&lt;blockquote style=\"text-align: center;\"&gt;html标签可以实现居中的效果 &lt;blockquote style=\"text-align: center;\"&gt; 嵌套使用 &lt;/blockquote&gt;&lt;/blockquote&gt;&gt; markdown标签&gt;&gt; markdown引用第二次 短引用标签 html普通引用标签, 会使包含在标签里面的文字被前后两个引号包含和段落引用的效果有区别： ⚠️ 短引用并没有使文字加红的效果，这里只是为了更好的区分 效果：短引用标签之前我是短引用标签短引用标签之前 代码：1短引用标签之前&lt;q&gt;&lt;font style=\"color:red\"&gt;我是短引用标签&lt;/font&gt;&lt;/q&gt;短引用标签之前 分割线效果 最终都是被解析为hr 使用原生的hr标签 可以定制自己的需求，一般使用markdown语法即可： 效果： 代码 _ 上面要空一行：1234---***&lt;hr style=\"border: 1px solid red\"/&gt; 向文章里面添加代码，分为两种 行内代码插入和代码块插入(前文黑色部分)： 效果：这是行内代码引用的效果&lt;br/&gt; 这是行内代码引用的效果 行内代码： 1234` 这是行内代码引用的效果&lt;br/&gt; 这是行内代码引用的效果` 代码块代码： 1234&lt;pre&gt; ``` html 设置要高亮的代码风格 使用时去掉 pre 标签 &lt;hr style=&quot;border: 1px solid red&quot;/&gt; ```&lt;/pre&gt; 有序和无需列表 有序列表 效果：1. 第一行2. 第二行 有序列表 代码 目前列表是默认从1递增，跟所输入的数字没有关系： 121. 第一行200. 第二行 无序列表代码 123+ 实现无序列表的第一种方式- 实现无序列表的第二种方式* 实现无序列表的第三种方式 插入图片 效果： 代码 目前没办法自定义宽高 有这个需求可以该用image标签：1![图片显示不出来时提示](/static/image/avatar.jpeg &apos;我的头像&apos;)![图片显示不出来时提示](/static/image/avatar.jpeg &apos;我的头像&apos;) 链接 效果：邮箱链接：&#97;&#x64;&#109;&#x69;&#x6e;&#x40;&#97;&#x64;&#x6d;&#105;&#x6e;&#x2e;&#99;&#111;&#x6d;超链接：Google 代码：12邮箱链接：&lt;chenhongvvei@gmail.com&gt;超链接：[Google](https://www.google.com/ncr) 特别感谢: Markdown 语法说明 (简体中文版) makrdown-wiki 简书 markdown常用的语法前人栽树，后人乘凉，感谢他们的贡献！","tags":[{"name":"markdown css","slug":"markdown-css","permalink":"http://blog.woodchan.com/tags/markdown-css/"}]},{"title":"搭建ss服务器","date":"2017-05-28T03:23:28.000Z","path":"2017/05/28/搭建ss服务器/","text":"是时候大步向前了 搭建vpn和ss服务器都能够实现翻墙的效果，但是ss服务器在客户端里面能够设置自动代理模式，可以很方便的实现访问国内国外网站两不误,所以只是翻墙的化，搭建一个ss服务器还是一个不错的选择 步骤 首先需要一个在国外的服务器(废话) 使用ssh登录 ssh root@ip地址，输入密码登录(win下可以下载putty或者使用gitbash,mac直接使用终端就好了) 安装pip环境： 1yum install python-setuptools &amp;&amp; easy_install pip 安装 shadowsocks 1pip install shadowsocks 安装完毕是不是很简单 启动 1ssserver -p 8888(要使用的端口号) -k password(自定义的密码) -m rc4-md5 现在就可以在客户端进行配置了，如果连接成功，会在命令行内打印连接的日志，比如访问的网站信息，注意必须要在服务器的安全组规则里面开放这个端口(如：阿里云服务器，默认只开启了22端口，需要手动添加要开放的端口) 停止命令 1sudo ssserver -d stop 现在ss服务器是在前台启动的，现在进行配置下，使他在后台运行 创建一个配置文件 1touch /etc/shadowsocks.json 编辑文件 1234567891011vim /etc/shadowsocks.json输入内容：&#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8888(自定义的端口号), &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword(自定义连接的密码)&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 最后一步 后台启动 1ssserver -c /etc/shadowsocks.json --user nobody -d start linux常用的命令 12ps -ef | grep shadowscokets # 查看指定的软件的运行情况kill -9 &apos;线程号&apos; # 杀死指定线程 特别感谢: SS+digital Ocean搭建教程 git 官方文档 前人栽树，后人乘凉，感谢他们的贡献！ ps 翻墙后可测试留言","tags":[{"name":"Shadowsockets 翻墙 ss","slug":"Shadowsockets-翻墙-ss","permalink":"http://blog.woodchan.com/tags/Shadowsockets-翻墙-ss/"}]},{"title":"使用mybatis插件","date":"2017-05-25T14:02:22.000Z","path":"2017/05/25/使用mybatis插件/","text":"mybstis插件实现拦截器效果","tags":[{"name":"mybatis 数据库","slug":"mybatis-数据库","permalink":"http://blog.woodchan.com/tags/mybatis-数据库/"}]},{"title":"hexo环境及跳坑","date":"2017-05-24T15:23:09.000Z","path":"2017/05/24/Hexo安装及踩坑记录/","text":"记录下安装hexo的过程中遇到的问题以及踩过的坑偶然间看到hexo+github教程，是个轻量级的博客，可以自己定制显示的各种样式，感觉比较高大上，于是乎就按照教程进行安装，但是安装的过程应该来说并不怎么顺利，所以就记录一下我在安装的过程中所遇到的问题 安装过程 前提条件： 需要安装node.js环境 需要有一个github账号 安装Hexo 1sudo npm install -g hexo 初始化一个hexo项目 1234新建一个文件夹，用来存放要写的文章，并在命令行里面进入这个文件夹hexo init 初始化项目hexo generate (简写 hexo g) 根据初始化的hello-word.md生成静态html文件hexo server (简写 hexo s) 在本地4000端口启动服务，访问http://localhost:4000 或者 http://127.0.0.1:4000 预览项目 【注】如果输入hexo s出现端口占用错误123ps -ef | grep hexo 查看被4000占用的端口，找到占用的线程号kill -9 “占用的线程号” 关掉占用4000端口的程序hexo s 重新启动程序 更换主题 现在可以在本地预览生成的博客的大致样子，但是默认的主题比较丑，所以需要去网上下载我们比较喜欢的主题 期间遇到的问题 当使用hexo d时可能会遇到 ERROR Deployer not found: git 或者 ERROR Deployer not found: github 解决方法： npm install hexo-deployer-git –save","tags":[{"name":"js hexo","slug":"js-hexo","permalink":"http://blog.woodchan.com/tags/js-hexo/"}]},{"title":"Hello","date":"2017-05-23T16:41:29.000Z","path":"2017/05/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hello hexo","slug":"hello-hexo","permalink":"http://blog.woodchan.com/tags/hello-hexo/"}]}]